## 1. 프로젝트 개요

- **목적**: 실시간 채팅 시스템 구축

- **개발자 레벨**: 2~3년차 백엔드 개발자

- **핵심 기술**: WebSocket + Redis Pub/Sub + QueryDSL

  

## 2. 기술 스택

```

- Java 17

- Spring Boot 3.2.x

- Spring Web, Spring Data JPA, Spring WebSocket

- Spring Data Redis (Pub/Sub)

- PostgreSQL (영구 저장소)

- Redis (메시지 브로커, 캐싱)

- QueryDSL (복잡한 쿼리)

- Gradle

- Lombok

```

  

## 3. 개발 단계별 계획

  

### Phase 1: 기본 기능 (현재 목표) ⭐

1. **엔티티 및 Repository 구축**

- User, ChatRoom, ChatRoomParticipant, ChatMessage

- QueryDSL 설정 및 Q클래스 생성

2. **REST API 구현**

- 방 목록 조회 (QueryDSL 활용)

- 방 생성

- 방 참여

- 메시지 조회 (페이징, QueryDSL 활용)

3. **WebSocket + Redis Pub/Sub 실시간 채팅**

- WebSocket 설정

- Redis Pub/Sub 구성

- 실시간 메시지 송수신

  

### Phase 2: Redis 캐싱 최적화 (나중)

- 최근 메시지 캐싱 (Redis List)

- 온라인 사용자 관리 (Redis Sorted Set)

- 방 정보 캐싱 (Redis Hash)

  

### Phase 3: 부가 기능 (나중)

- 안읽은 메시지 카운트

- 메시지 페이지네이션 고도화

- 최근 메시지 미리보기

- 타이핑 인디케이터

  

### Phase 4: Kafka 마이그레이션 (나중)

- Kafka 설정 및 토픽 생성

- Redis Pub/Sub → Kafka로 전환

- 메시지 영속성 및 재처리 로직

  

**현재는 Phase 1만 집중하며, 한 단계씩 완성하고 진행**

  

## 4. 데이터베이스 설계

  

### 엔티티 구조

```java

// User (사용자)

- id: Long (PK, Auto Increment)

- username: String (unique, not null, 로그인용)

- nickname: String (not null, 표시용)

- createdAt: LocalDateTime (not null)

  

// ChatRoom (채팅방)

- id: Long (PK, Auto Increment)

- name: String (not null, 방 제목)

- type: RoomType (enum: PUBLIC, PRIVATE)

- maxParticipants: Integer (nullable, null=무제한)

- createdAt: LocalDateTime (not null)

- createdBy: Long (생성자 user id)

  

// ChatRoomParticipant (참여자)

- id: Long (PK, Auto Increment)

- roomId: Long (FK → ChatRoom)

- userId: Long (FK → User)

- joinedAt: LocalDateTime (not null)

- Unique Key: (roomId, userId) - 중복 참여 방지

  

// ChatMessage (메시지)

- id: Long (PK, Auto Increment)

- roomId: Long (FK → ChatRoom, indexed)

- senderId: Long (FK → User)

- content: String (not null)

- messageType: MessageType (enum: TEXT, IMAGE, SYSTEM)

- sentAt: LocalDateTime (not null, indexed)

- Index: (roomId, sentAt) - 메시지 조회 성능

```

  

### Enum 정의

```java

public enum RoomType {

PUBLIC, // 공개방

PRIVATE // 비공개방

}

  

public enum MessageType {

TEXT, // 일반 텍스트

IMAGE, // 이미지 (URL)

SYSTEM // 시스템 메시지 (입장/퇴장)

}

```

  

## 5. API 설계

  

### REST API 엔드포인트

```

GET /api/rooms - 전체 방 목록 조회 (QueryDSL: 참여자 수 포함)

POST /api/rooms - 방 생성

GET /api/rooms/{roomId} - 방 상세 조회 (QueryDSL: 참여자 목록 포함)

POST /api/rooms/{roomId}/join - 방 참여

DELETE /api/rooms/{roomId}/leave - 방 나가기 (Phase 3)

GET /api/rooms/my - 내가 참여한 방 목록 (QueryDSL)

GET /api/rooms/{roomId}/messages - 메시지 조회 (페이징, QueryDSL: sender 정보 포함)

  

헤더: userId (Long) - 임시 인증 (나중에 JWT로 교체)

```

  

### REST API Request/Response DTO

  

#### 방 생성 요청

```json

POST /api/rooms

{

"name": "자유 채팅방",

"type": "PUBLIC",

"maxParticipants": 50

}

```

  

#### 방 목록 응답

```json

GET /api/rooms

{

"rooms": [

{

"id": 1,

"name": "자유 채팅방",

"type": "PUBLIC",

"participantCount": 15,

"maxParticipants": 50,

"createdAt": "2024-01-01T10:00:00"

}

]

}

```

  

#### 메시지 조회 응답

```json

GET /api/rooms/1/messages?page=0&size=50

{

"messages": [

{

"id": 100,

"senderId": 5,

"senderNickname": "철수",

"content": "안녕하세요!",

"messageType": "TEXT",

"sentAt": "2024-01-01T10:05:00"

}

],

"hasNext": true

}

```

  

### WebSocket 엔드포인트

```

연결: ws://localhost:8080/ws

구독: /topic/room/{roomId}

발행: /app/chat.sendMessage/{roomId}

  

발행 메시지 형식:

{

"content": "안녕하세요!",

"messageType": "TEXT"

}

  

헤더에 userId 필수 포함

```

  

## 6. 프로젝트 구조

```

src/main/java/com/example/chat/

├── domain/

│ ├── user/

│ │ ├── User.java (Entity)

│ │ ├── UserRepository.java (JPA Repository)

│ │ ├── UserRepositoryCustom.java (QueryDSL 인터페이스)

│ │ ├── UserRepositoryImpl.java (QueryDSL 구현체)

│ │ └── UserService.java (비즈니스 로직)

│ ├── room/

│ │ ├── ChatRoom.java (Entity)

│ │ ├── ChatRoomRepository.java

│ │ ├── ChatRoomRepositoryCustom.java

│ │ ├── ChatRoomRepositoryImpl.java

│ │ ├── ChatRoomService.java

│ │ ├── ChatRoomParticipant.java (Entity)

│ │ ├── ChatRoomParticipantRepository.java

│ │ ├── ChatRoomParticipantRepositoryCustom.java

│ │ └── ChatRoomParticipantRepositoryImpl.java

│ └── message/

│ ├── ChatMessage.java (Entity)

│ ├── ChatMessageRepository.java

│ ├── ChatMessageRepositoryCustom.java

│ ├── ChatMessageRepositoryImpl.java

│ └── ChatMessageService.java

├── api/

│ ├── RoomController.java (REST API)

│ └── MessageController.java (WebSocket)

├── dto/

│ ├── request/

│ │ ├── CreateRoomRequest.java

│ │ ├── JoinRoomRequest.java

│ │ └── ChatMessageRequest.java

│ └── response/

│ ├── RoomResponse.java

│ ├── RoomDetailResponse.java

│ ├── RoomListResponse.java

│ └── MessageResponse.java

├── config/

│ ├── WebSocketConfig.java (WebSocket 설정)

│ ├── RedisConfig.java (Redis Pub/Sub 설정)

│ └── QueryDslConfig.java (QueryDSL 설정)

├── redis/

│ ├── RedisPublisher.java (메시지 발행)

│ └── RedisSubscriber.java (메시지 구독)

├── exception/

│ ├── GlobalExceptionHandler.java

│ ├── BusinessException.java

│ ├── RoomNotFoundException.java

│ └── UserNotFoundException.java

└── ChatApplication.java

  

src/main/generated/ (QueryDSL Q클래스 자동 생성 디렉토리)

```

  

## 7. QueryDSL 활용 시나리오

  

### QueryDSL을 사용하는 경우

1. **복잡한 조인이 필요한 경우**

- 방 목록 조회 시 참여자 수 계산

- 메시지 조회 시 발신자 정보 포함

  

2. **동적 쿼리가 필요한 경우**

- 방 검색 (이름, 타입, 참여 가능 여부 등 조건부)

- 메시지 검색 (발신자, 날짜 범위, 키워드 등)

  

3. **복잡한 집계 쿼리**

- 통계 데이터 (방별 메시지 수, 활성 사용자 수 등)

  

### QueryDSL 사용 예시

  

#### ChatRoomRepositoryCustom.java

```java

public interface ChatRoomRepositoryCustom {

List<RoomWithCountDto> findAllWithParticipantCount();

List<ChatRoom> findMyRooms(Long userId);

RoomDetailDto findDetailById(Long roomId);

}

```

  

#### ChatRoomRepositoryImpl.java

```java

@RequiredArgsConstructor

public class ChatRoomRepositoryImpl implements ChatRoomRepositoryCustom {

private final JPAQueryFactory queryFactory;

@Override

public List<RoomWithCountDto> findAllWithParticipantCount() {

return queryFactory

.select(Projections.constructor(

RoomWithCountDto.class,

chatRoom.id,

chatRoom.name,

chatRoom.type,

chatRoom.maxParticipants,

chatRoomParticipant.count().intValue(),

chatRoom.createdAt

))

.from(chatRoom)

.leftJoin(chatRoomParticipant)

.on(chatRoomParticipant.roomId.eq(chatRoom.id))

.groupBy(chatRoom.id)

.fetch();

}

}

```

  

#### ChatMessageRepositoryCustom.java

```java

public interface ChatMessageRepositoryCustom {

List<MessageWithSenderDto> findMessagesWithSender(Long roomId, Pageable pageable);

List<ChatMessage> searchMessages(Long roomId, String keyword, LocalDateTime from, LocalDateTime to);

}

```

  

## 8. Redis 아키텍처

  

### 메시지 플로우

```

1. 클라이언트 A가 메시지 전송 (WebSocket)

↓

2. Spring Boot 서버가 수신

↓

3. PostgreSQL에 메시지 저장

↓

4. Redis Pub/Sub에 메시지 발행 (topic: "chat:room:{roomId}")

↓

5. 모든 서버 인스턴스가 구독하여 수신

↓

6. 각 서버가 자신의 WebSocket 클라이언트들에게 브로드캐스트

```

  

### Redis 채널 네이밍

```

chat:room:{roomId} - 방별 메시지 채널

예: chat:room:1, chat:room:2

```

  

## 9. 의존성 (build.gradle)

```gradle

plugins {

id 'java'

id 'org.springframework.boot' version '3.2.0'

id 'io.spring.dependency-management' version '1.1.4'

}

  

group = 'com.example'

version = '0.0.1-SNAPSHOT'

  

java {

sourceCompatibility = '17'

}

  

configurations {

compileOnly {

extendsFrom annotationProcessor

}

}

  

repositories {

mavenCentral()

}

  

dependencies {

// Spring Boot Starters

implementation 'org.springframework.boot:spring-boot-starter-web'

implementation 'org.springframework.boot:spring-boot-starter-data-jpa'

implementation 'org.springframework.boot:spring-boot-starter-websocket'

implementation 'org.springframework.boot:spring-boot-starter-data-redis'

implementation 'org.springframework.boot:spring-boot-starter-validation'

// Database

runtimeOnly 'org.postgresql:postgresql'

// QueryDSL

implementation 'com.querydsl:querydsl-jpa:5.0.0:jakarta'

annotationProcessor "com.querydsl:querydsl-apt:5.0.0:jakarta"

annotationProcessor "jakarta.annotation:jakarta.annotation-api"

annotationProcessor "jakarta.persistence:jakarta.persistence-api"

// JSON

implementation 'com.fasterxml.jackson.core:jackson-databind'

implementation 'com.fasterxml.jackson.datatype:jackson-datatype-jsr310'

// Lombok

compileOnly 'org.projectlombok:lombok'

annotationProcessor 'org.projectlombok:lombok'

// Test

testImplementation 'org.springframework.boot:spring-boot-starter-test'

}

  

tasks.named('test') {

useJUnitPlatform()

}

  

// QueryDSL 설정

def querydslDir = "$buildDir/generated/querydsl"

  

sourceSets {

main.java.srcDirs += [ querydslDir ]

}

  

tasks.withType(JavaCompile) {

options.annotationProcessorGeneratedSourcesDirectory = file(querydslDir)

}

  

clean.doLast {

file(querydslDir).deleteDir()

}

```

  

## 10. 설정 파일

  

### application.yml

```yaml

spring:

application:

name: chat-service

datasource:

url: jdbc:postgresql://localhost:5432/chatdb

username: postgres

password: password

driver-class-name: org.postgresql.Driver

jpa:

hibernate:

ddl-auto: update

show-sql: true

properties:

hibernate:

format_sql: true

default_batch_fetch_size: 100

data:

redis:

host: localhost

port: 6379

  

server:

port: 8080

  

logging:

level:

com.example.chat: DEBUG

org.springframework.web.socket: DEBUG

org.hibernate.SQL: DEBUG

org.hibernate.type.descriptor.sql.BasicBinder: TRACE

```

  

### QueryDslConfig.java

```java

@Configuration

public class QueryDslConfig {

@PersistenceContext

private EntityManager entityManager;

@Bean

public JPAQueryFactory jpaQueryFactory() {

return new JPAQueryFactory(entityManager);

}

}

```

  

## 11. 코딩 컨벤션

  

### 일반 규칙

- **패키지명**: 소문자, 단수형

- **클래스명**: PascalCase

- **메서드/변수명**: camelCase

- **상수**: UPPER_SNAKE_CASE

- **DTO 네이밍**: ~Request, ~Response, ~Dto

- **예외 네이밍**: ~Exception

  

### Lombok 활용

- **엔티티**: @Getter, @NoArgsConstructor(access = AccessLevel.PROTECTED), @Builder

- **DTO**: @Getter, @NoArgsConstructor, @AllArgsConstructor, @Builder

- **서비스/컨트롤러**: @RequiredArgsConstructor, @Slf4j

  

### QueryDSL 규칙

- **Custom Repository 네이밍**: ~RepositoryCustom (인터페이스), ~RepositoryImpl (구현체)

- **DTO Projection**: Projections.constructor() 또는 @QueryProjection 사용

- **동적 쿼리**: BooleanBuilder 또는 BooleanExpression 메서드 분리

  

## 12. 개발 우선순위

  

### Step 1: 기본 설정 및 엔티티

1. build.gradle 의존성 추가

2. application.yml 설정

3. QueryDslConfig 설정

4. User 엔티티 + Repository + RepositoryImpl

5. ChatRoom 엔티티 + Repository + RepositoryImpl

6. ChatRoomParticipant 엔티티 + Repository

7. ChatMessage 엔티티 + Repository + RepositoryImpl

8. **빌드 후 Q클래스 생성 확인**

  

### Step 2: 서비스 계층

1. UserService (간단한 CRUD)

2. ChatRoomService (방 생성, 조회, 참여 - QueryDSL 활용)

3. ChatMessageService (메시지 저장, 조회 - QueryDSL 활용)

  

### Step 3: REST API

1. DTO 작성 (Request, Response)

2. RoomController (방 관련 API)

3. GlobalExceptionHandler

4. **Postman으로 API 테스트**

  

### Step 4: WebSocket + Redis

1. RedisConfig 설정

2. WebSocketConfig 설정

3. RedisPublisher, RedisSubscriber 구현

4. MessageController (WebSocket)

5. **WebSocket 클라이언트로 실시간 채팅 테스트**

  

## 13. QueryDSL 구현 가이드

  

### 기본 CRUD는 JpaRepository 사용

```java

// 간단한 조회는 JpaRepository 메서드 사용

Optional<ChatRoom> findById(Long id);

List<ChatRoom> findAll();

```

  

### 복잡한 쿼리는 QueryDSL 사용

```java

// 참여자 수를 포함한 방 목록

List<RoomWithCountDto> findAllWithParticipantCount();

  

// 발신자 정보를 포함한 메시지 목록

List<MessageWithSenderDto> findMessagesWithSender(Long roomId, Pageable pageable);

```

  

### DTO Projection 패턴

```java

// 1. Constructor Projection (권장)

Projections.constructor(

RoomWithCountDto.class,

chatRoom.id,

chatRoom.name,

chatRoomParticipant.count()

)

  

// 2. Fields Projection

Projections.fields(

RoomWithCountDto.class,

chatRoom.id,

chatRoom.name

)

  

// 3. @QueryProjection (DTO에 어노테이션 추가 후 Q클래스 생성)

new QRoomWithCountDto(chatRoom.id, chatRoom.name)

```

  

## 14. 주요 요구사항

  

### 예외 처리

- GlobalExceptionHandler로 일관된 예외 응답

- 커스텀 예외: RoomNotFoundException, UserNotFoundException, RoomFullException 등

- 응답 형식:

```json

{

"error": "ROOM_NOT_FOUND",

"message": "존재하지 않는 방입니다.",

"timestamp": "2024-01-01T10:00:00"

}

```

  

### Validation

- @Valid, @NotNull, @NotBlank, @Size 등 적극 활용

- DTO에 validation 적용

- 커스텀 validation: @ValidRoomType, @ValidMessageType 등

  

### 트랜잭션

- Service 계층에 @Transactional 적용

- 읽기 전용: @Transactional(readOnly = true)

- QueryDSL 조회도 트랜잭션 내에서 실행

  

### 로깅

- 중요 로직에 로그 추가 (SLF4J)

- 로그 레벨: ERROR, WARN, INFO, DEBUG

- QueryDSL 쿼리 로그 활성화

  

### 페이징

- Spring Data의 Pageable 활용

- QueryDSL에서 offset/limit 적용

```java

queryFactory

.selectFrom(chatMessage)

.where(chatMessage.roomId.eq(roomId))

.orderBy(chatMessage.sentAt.desc())

.offset(pageable.getOffset())

.limit(pageable.getPageSize())

.fetch();

```

  

## 15. 개발 시 주의사항

  

### 점진적 개발

- **한 번에 하나씩**: 엔티티 → Repository → Service → Controller

- **단계별 테스트**: 각 단계 완료 후 동작 확인

- **커밋 단위**: 기능별로 작게 나누어 커밋

  

### QueryDSL 주의사항

- **Q클래스 생성**: build 후 src/main/generated에 생성 확인

- **IDE 인식**: IntelliJ에서 generated 폴더를 소스 폴더로 인식시키기

- **N+1 문제**: fetch join 적극 활용

- **카운트 쿼리 최적화**: fetchCount() 대신 fetch().size() 고려

  

### 코드 품질

- 각 클래스/메서드에 간단한 JavaDoc 주석

- 매직 넘버/문자열 상수화

- 코드 중복 최소화 (QueryDSL BooleanExpression 메서드 분리)

  

### 성능 고려

- **Batch Fetch Size**: application.yml에 설정 (default_batch_fetch_size: 100)

- **인덱스**: roomId, sentAt 등 자주 조회되는 컬럼에 인덱스

- **쿼리 최적화**: 필요한 컬럼만 조회 (Projection 활용)

  

## 16. 테스트 전략

  

### Phase 1 (현재)

- **수동 테스트**

- Postman으로 REST API 테스트

- WebSocket 클라이언트로 실시간 채팅 테스트

- 각 기능별 시나리오 작성 및 테스트

  

### Phase 2 이후

- **단위 테스트**

- Repository 테스트 (QueryDSL 쿼리 검증)

- Service 테스트 (비즈니스 로직 검증)

- **통합 테스트**

- API 테스트

- WebSocket 연결 테스트

  

## 17. 제약사항 및 간소화

  

### 현재 단계에서 제외

- ❌ 인증/인가 (JWT, Spring Security)

- 헤더에 userId만 전달

- ❌ 프론트엔드

- Postman, WebSocket 클라이언트로 테스트

- ❌ 성능 최적화

- 일단 동작하는 코드 우선

- ❌ 배포 설정

- 로컬 개발 환경만

- ❌ 단위 테스트

- Phase 2 이후 추가

  

### 나중에 추가할 기능

- 안읽은 메시지 카운트

- 메시지 수정/삭제

- 파일 업로드 (이미지)

- 타이핑 인디케이터

- 온라인 상태 표시

- 메시지 검색 (QueryDSL 동적 쿼리)

- 통계 및 분석 (QueryDSL 집계)

  

## 18. Docker 설정 (개발 환경)

  

### docker-compose.yml

```yaml

version: '3.8'

services:

postgres:

image: postgres:15

container_name: chat-postgres

ports:

- "5432:5432"

environment:

POSTGRES_DB: chatdb

POSTGRES_USER: postgres

POSTGRES_PASSWORD: password

volumes:

- postgres-data:/var/lib/postgresql/data

redis:

image: redis:7-alpine

container_name: chat-redis

ports:

- "6379:6379"

volumes:

- redis-data:/data

  

volumes:

postgres-data:

redis-data:

```

  

실행 명령어:

```bash

# 컨테이너 시작

docker-compose up -d

  

# 로그 확인

docker-compose logs -f

  

# 컨테이너 중지

docker-compose down

  

# 데이터까지 삭제

docker-compose down -v

```

  

## 19. 개발 시작 가이드

  

### 1단계: 프로젝트 생성

```bash

# Spring Initializr 또는 IDE에서 프로젝트 생성

# - Spring Boot 3.2.x

# - Java 17

# - Gradle

```

  

### 2단계: 의존성 설정

- build.gradle에 의존성 추가 (위 9번 항목 참조)

- Gradle Sync

  

### 3단계: 설정 파일 작성

- application.yml 작성 (위 10번 항목 참조)

- QueryDslConfig.java 작성

  

### 4단계: Docker 실행

```bash

docker-compose up -d

```

  

### 5단계: Claude Code에 요청

```

"이제 User 엔티티와 UserRepository를 만들어줘.

엔티티 설계는 위 가이드 문서의 4번 항목을 참고하고,

UserRepositoryCustom 인터페이스도 미리 만들어줘. (구현은 나중에)

완료되면 gradle build를 실행해서 Q클래스가 생성되는지 확인해줘."

```

  

## 20. 자주 발생할 수 있는 이슈 및 해결

  

### QueryDSL Q클래스 생성 안됨

```bash

# 해결: Gradle clean 후 build

./gradlew clean build

```

  

### IntelliJ에서 Q클래스 인식 안됨

```

1. File → Project Structure → Modules

2. build/generated/querydsl 폴더를 Sources로 마크

3. Apply → OK

```

  

### WebSocket CORS 문제

```java

// WebSocketConfig에서 설정

@Override

public void registerStompEndpoints(StompEndpointRegistry registry) {

registry.addEndpoint("/ws")

.setAllowedOriginPatterns("*")

.withSockJS();

}

```

  

### Redis 연결 실패

```bash

# Redis 실행 확인

docker ps | grep redis

  

# Redis 접속 테스트

docker exec -it chat-redis redis-cli ping

# 응답: PONG

```

  

### JPA N+1 문제

```java

// QueryDSL fetch join 사용

queryFactory

.selectFrom(chatMessage)

.join(chatMessage.sender, user).fetchJoin()

.where(chatMessage.roomId.eq(roomId))

.fetch();

```

  

### PostgreSQL 한글 인코딩 문제

```yaml

# application.yml에 추가

spring:

datasource:

url: jdbc:postgresql://localhost:5432/chatdb?useUnicode=true&characterEncoding=utf8

```

  

## 21. 참고 자료

  

### 공식 문서

- [Spring Boot Documentation](https://docs.spring.io/spring-boot/docs/current/reference/html/)

- [Spring WebSocket](https://docs.spring.io/spring-framework/reference/web/websocket.html)

- [QueryDSL Documentation](http://querydsl.com/static/querydsl/latest/reference/html/)

- [Redis Documentation](https://redis.io/docs/)

  

### 추천 학습 자료

- QueryDSL 기본 사용법

- WebSocket STOMP 프로토콜

- Redis Pub/Sub 패턴

- JPA N+1 문제 해결

  

## 22. 추가 개선 아이디어

  

### 성능 최적화

- Redis 캐싱 전략 (Phase 2)

- 메시지 조회 쿼리 최적화 (커버링 인덱스)

- 페이징 성능 개선 (No Offset 방식)

  

### 기능 확장

- 메시지 검색 (Elasticsearch 또는 PostgreSQL Full-Text Search)

- 파일 업로드 (S3 또는 MinIO)

- 알림 기능 (FCM 또는 WebSocket)

- 방 권한 관리 (방장, 관리자)

  

### 아키텍처 개선

- CQRS 패턴 적용

- Event Sourcing

- Kafka로 마이그레이션 (Phase 4)

- 멀티 모듈 구조

  

---

  

## 최종 체크리스트

  

### Phase 1 완료 조건

- [ ] 모든 엔티티 생성 및 Q클래스 생성 확인

- [ ] 방 생성/조회/참여 API 동작 확인

- [ ] 메시지 조회 API 동작 확인 (QueryDSL 적용)

- [ ] WebSocket 연결 및 실시간 메시지 송수신 확인

- [ ] Redis Pub/Sub 동작 확인 (여러 클라이언트 동시 접속)

- [ ] 예외 처리 및 Validation 동작 확인

  

### 개발 완료 후

- [ ] README.md 작성 (프로젝트 설명, 실행 방법)

- [ ] API 문서 작성 (Postman Collection 또는 Swagger)

- [ ] 코드 리팩토링 및 주석 보완

- [ ] GitHub에 업로드

  

---

  

**이 가이드는 Phase 1 기본 기능 구현을 위한 것입니다.**

**각 단계를 천천히 완성하면서 진행하세요!**